import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { ImprovedNoise } from 'three/addons/math/ImprovedNoise.js';
import { Simulation } from './simulation.js';

/**
 * Render.js
 * Handles all Three.js scene setup, rendering, and object creation/removal.
 */

let engine; // Reference to the main game engine
let scene, camera, renderer, controls, raycaster, mouse;
let ambientLight, dirLight;
let groundMesh, buildCursor;
let terrainData; // To store height data

// World config
const GRID_SIZE = 1000;
const CELL_SIZE = 10;
const TERRAIN_SEGMENTS = 100; // PlaneGeometry segments (GRID_SIZE / CELL_SIZE)

// Object containers
const objectMeshes = new Map(); // key -> mesh

// Materials
const materials = {
    ground: new THREE.MeshStandardMaterial({ 
        color: 0x559020, 
        roughness: 1.0, 
        metalness: 0.0,
        vertexColors: true // Enable vertex colors for height shading
    }),
    cursor: new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true }),
    cursorInvalid: new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.5, transparent: true }),
    road: new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.8, metalness: 0.1 }),
    residential: new THREE.MeshStandardMaterial({ color: 0x00cc00, roughness: 0.8, metalness: 0.1 }),
    commercial: new THREE.MeshStandardMaterial({ color: 0x0000cc, roughness: 0.8, metalness: 0.1 }),
    industrial: new THREE.MeshStandardMaterial({ color: 0xcccc00, roughness: 0.8, metalness: 0.1 }),
};

// Geometries
const geometries = {
    zone: new THREE.BoxGeometry(CELL_SIZE * 0.9, CELL_SIZE, CELL_SIZE * 0.9),
    // Road geometry is now a plane so it can sit on terrain
    road: new THREE.PlaneGeometry(CELL_SIZE, CELL_SIZE), 
};

export function init(gameEngine) {
    engine = gameEngine;
    const container = document.getElementById('container');

    // Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb); // Sky blue
    scene.fog = new THREE.Fog(0x87ceeb, 500, 1500);

    // Camera
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(100, 150, 100);
    camera.lookAt(0, 0, 0);

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(renderer.domElement);

    // Lighting
    ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(100, 200, 50);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 2048;
    dirLight.shadow.mapSize.height = 2048;
    dirLight.shadow.camera.top = 300;
    dirLight.shadow.camera.bottom = -300;
    dirLight.shadow.camera.left = -300;
    dirLight.shadow.camera.right = 300;
    scene.add(dirLight);

    // Ground (Now Procedural!)
    groundMesh = createProceduralGround();
    groundMesh.receiveShadow = true;
    scene.add(groundMesh);

    // Build Cursor
    buildCursor = new THREE.Mesh(
        new THREE.BoxGeometry(CELL_SIZE, 0.5, CELL_SIZE),
        materials.cursor
    );
    buildCursor.visible = false;
    scene.add(buildCursor);

    // Controls
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2 - 0.1; 

    // Raycaster
    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    // Event Listeners
    window.addEventListener('resize', onWindowResize);
    container.addEventListener('pointermove', onPointerMove);
    container.addEventListener('pointerdown', onPointerDown);
}

export function animate(deltaTime) {
    controls.update(deltaTime);
    renderer.render(scene, camera);
}

function createProceduralGround() {
    const geometry = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE, TERRAIN_SEGMENTS, TERRAIN_SEGMENTS);
    const noise = new ImprovedNoise();
    terrainData = []; // Store height data

    const vertices = geometry.attributes.position;
    const colors = [];
    const color = new THREE.Color();
    const peakHeight = 60;
    const noiseScale = 0.01;

    for (let i = 0, j = 0; i < vertices.count; i++, j += 3) {
        const x = vertices.array[j];
        const y = vertices.array[j + 1]; // This is z in world space
        
        // Generate noise
        let height = noise.perlin2(x * noiseScale, y * noiseScale) * peakHeight;
        height = Math.max(0, height); // Clamp to prevent holes
        
        vertices.array[j + 2] = height; // This is y in world space (up)
        terrainData[i] = height;

        // Set vertex color based on height
        if (height < 10) {
            color.set(0x60a91f); // Grassy
        } else if (height < 30) {
            color.set(0x888888); // Rock
        } else {
            color.set(0xffffff); // Snow
        }
        colors.push(color.r, color.g, color.b);
    }
    
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geometry.computeVertexNormals(); // Recalculate normals for correct lighting
    
    const ground = new THREE.Mesh(geometry, materials.ground);
    ground.rotation.x = -Math.PI / 2; // Rotate to be flat
    return ground;
}

/**
 * Gets the terrain height at a specific world (x, z) coordinate.
 * This is an approximation based on the nearest vertex.
 */
export function getTerrainHeight(worldX, worldZ) {
    // Convert world coords to plane geometry coords
    const planeX = worldX;
    const planeZ = worldZ;
    
    // Convert plane coords to grid index
    const x = Math.round((planeX + GRID_SIZE / 2) / CELL_SIZE);
    const z = Math.round((planeZ + GRID_SIZE / 2) / CELL_SIZE);
    
    const index = z * (TERRAIN_SEGMENTS + 1) + x;
    
    return terrainData[index] || 0;
}

// --- Object Mesh Creation ---

export function createRoadMesh(pos, height) {
    const key = Simulation.getKey(pos);
    if (objectMeshes.has(key)) return; // Already exists

    // Create a plane and rotate it to match road direction
    const mesh = new THREE.Mesh(geometries.road, materials.road);
    mesh.position.set(pos.x, height + 0.2, pos.z); // Slightly above terrain
    mesh.rotation.x = -Math.PI / 2; // Lay flat
    mesh.castShadow = true;
    mesh.receiveShadow = true;

    scene.add(mesh);
    objectMeshes.set(key, mesh);
}

export function createZoneMesh(pos, type, height) {
    const key = Simulation.getKey(pos);
    if (objectMeshes.has(key)) return;

    const mesh = new THREE.Mesh(geometries.zone, materials[type]);
    mesh.position.set(pos.x, height + (CELL_SIZE / 2), pos.z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;

    scene.add(mesh);
    objectMeshes.set(key, mesh);
}

export function removeMesh(object) {
    const key = Simulation.getKey(object);
    const mesh = objectMeshes.get(key);
    if (mesh) {
        scene.remove(mesh);
        // Note: We don't dispose shared geometries/materials
        objectMeshes.delete(key);
    }
}

// --- Build Cursor ---

export function updateBuildCursor(pos, height, isOccupied) {
    buildCursor.position.set(pos.x, height + 0.25, pos.z);
    buildCursor.material = isOccupied ? materials.cursorInvalid : materials.cursor;
    buildCursor.visible = true;
}

export function hideBuildCursor() {
    buildCursor.visible = false;
}


// --- Event Handlers ---

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function getIntersection(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(groundMesh);
    return intersects.length > 0 ? intersects[0].point : null;
}

function onPointerMove(event) {
    const point = getIntersection(event);
    if (point) {
        engine.onWorldMove(point);
    } else {
        hideBuildCursor();
    }
}

function onPointerDown(event) {
    if (event.button !== 0) return; // Only left click
    const point = getIntersection(event);
    if (point) {
        engine.onWorldClick(point);
    }
}
